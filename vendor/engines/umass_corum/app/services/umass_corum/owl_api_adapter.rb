# frozen_string_literal: true

module UmassCorum

  class OwlApiAdapter

    TIMEOUT = 3
    NO_USER_ERROR = "No such user exists"

    def self.params
      {
        Server: Rails.env.production? ? "owl-ehs" : "owl-ehsstaging",
        UserType: "Student",
        fxn: "trcompleted",
        Mode: Rails.env.development? ? "IALSDummy" : "IALSCorum", # Avoid IP violations in development
      }
    end

    # Note: If you are not on the UMass VPN, both servers are inaccessible due to firewalling
    def self.host
      Rails.env.production? ? "owl.umass.edu" : "owlstage.umass.edu"
    end

    def self.fetch(netid)
      ActiveSupport::Notifications.instrument "get_owl_certifications.umass_corum" do |payload|
        payload[:emplid] = netid

        uri = URI.parse("https://#{host}/owlj/servlet/OwlPreLogin")
        uri.query = URI.encode_www_form(params.merge("ID" => netid))

        Net::HTTP.start(uri.host, uri.port, open_timeout: TIMEOUT, read_timeout: TIMEOUT, use_ssl: true) do |http|
          req = Net::HTTP::Get.new(uri)
          response = http.request(req)
          payload[:response] = response
          response.body
        end
      end
    end

    def initialize(user)
      @user = user
    end

    def certified?(certificate)
      # Email users would never exist in the external system. They must have a valid netid.
      return false if @user.email_user? || user_not_found?

      completed_certificate_ids.include?(certificate.name)
    end

    def user_not_found?
      response.dig("error", "message") == NO_USER_ERROR
    end

    private

    def completed_certificate_ids
      response["certifications"].map { |certification_data| initial_certificate_id_for(certification_data["id"]) }.uniq
    end

    # Replace refresher certificate codes with initial certificate codes
    def initial_certificate_id_for(certificate_id)
      case certificate_id
      when "BIOSFTYLAB"
        "BIOSAFE"
      when "LABRSAFE"
        "LABSAFE"
      when "RADSFTRFSH"
        "RADSAFE"
      else
        certificate_id
      end
    end

    def response
      return @response if @response

      @response = JSON.parse(self.class.fetch(@user.username))
      error_message = @response.dig("error", "message")
      raise error_message if @response["error"] && error_message != NO_USER_ERROR

      @response
    end

  end

end
