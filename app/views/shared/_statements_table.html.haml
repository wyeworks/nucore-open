- show_reconcile_notes = local_assigns[:show_reconcile_notes]
- if @statements.empty?
  %p.notice= text("no_statements")
- else
  - if SettingsHelper.feature_on?(:multiple_statements_download)
    - form_url = @account ? download_selected_account_statements_path(@account) : download_selected_facility_statements_path(current_facility)
    = form_tag form_url, method: :post, id: "statements-form" do
      .pull-right.mb-3
        = submit_tag t("statements.download_selected"), class: "btn btn-primary js--download-selected-statements", disabled: true
        %span.js--download-spinner.ml-2{style: "display: none;"}
          %i.fa.fa-spinner.fa-spin
          %span.ml-1= t("statements.downloading")
  %table.table.table-striped.table-hover
    %thead
      %tr
        - if SettingsHelper.feature_on?(:multiple_statements_download)
          %th
            %input{type: "checkbox", class: "js--select-all-statements"}
        %th= Statement.human_attribute_name(:invoice_number)
        %th= Statement.human_attribute_name(:created_at)
        %th= Statement.human_attribute_name(:account_admins)
        - unless @account
          %th= Account.model_name.human
        - if current_facility&.cross_facility?
          %th= Facility.model_name.human
        %th.currency # of #{Order.model_name.human.pluralize}
        %th.currency= Statement.human_attribute_name(:total_cost)
        %th= t("statements.closed_at")
        %th= t("statements.closed_by")
        %th= Statement.human_attribute_name(:status)
    %tbody
      - StatementPresenter.wrap(@statements).each do |s|
        %tr.statement
          - if SettingsHelper.feature_on?(:multiple_statements_download)
            %td.centered
              - if !s.canceled_at
                = check_box_tag "statement_ids[]", s.id, false, class: "js--statement-checkbox", data: { invoice_number: s.invoice_number }
          %td.centered
            = "##{s.invoice_number}"
            - unless s.canceled_at
              %br
              - # TODO: Refactor Statement#order_details to go through statement_rows so we can generate PDFs for canceled statements
              - path = current_facility ? statement_path(s) : account_statement_path(s.account, s, format: :pdf)
              = link_to t("statements.pdf.download"), path
              - if current_facility
                - if SettingsHelper.feature_on?(:send_statement_emails)
                  %br
                  - confirm = "You are about to re-send this invoice to the following recipients: #{s.users_to_notify.join(", ")}"
                  = link_to(t("statements.resend"),
                    resend_emails_facility_statement_path(current_facility, s),
                    method: :post,
                    class: "js--resend",
                    data: { confirm: confirm })

                - if s.can_cancel? && show_cancel_button
                  = button_to(t("statements.cancel"),
                    cancel_facility_statement_path(current_facility, s),
                    class: "btn btn-danger",
                    data: { confirm: "Are you sure you want to cancel?" })
          %td= format_usa_datetime(s.created_at)
          %td
            - s.account.notify_users.each do |user|
              = mail_to user.email, user.full_name
          - unless @account
            %td= link_to s.account, facility_account_path(current_facility, s.account)
          - if current_facility&.cross_facility?
            %td= s.facility.name
          %td.currency= s.order_details.count
          %td.currency= number_to_currency(s.total_cost)
          %td
            %ul.unstyled
              - s.closed_by_times.each do |closed_by_time|
                %li.statement__nowrap-text= closed_by_time
          %td
            %ul.unstyled
              - s.closed_by_user_full_names.each do |closed_by_name|
                %li.statement__nowrap-text= closed_by_name
          %td
            %div
              %span= Statement.human_attribute_name("status.#{s.status}")
            - if show_reconcile_notes && s.reconcile_notes.present?
              %div
                %small
                  %strong= "#{t('statements.notes')}:"
              %div
                %small= s.reconcile_notes.shift
              - collapsable_section_id = "statement-notes-#{s.id}"
              %ul.unstyled.collapse{ id: collapsable_section_id }
                - s.reconcile_notes.each do |note|
                  %li
                    %small= note
              - if s.reconcile_notes.length > 0
                %a{ role: "button",
                href: "##{collapsable_section_id}",
                data: { toggle: "collapse" },
                aria: { expanded: false, controls: collapsable_section_id } }
                  %small= t("statements.expand")


  = will_paginate(@statements)

  - if SettingsHelper.feature_on?(:multiple_statements_download)
    = javascript_tag do
      :plain
        document.addEventListener('DOMContentLoaded', function() {
          var checkboxes = document.querySelectorAll('.js--statement-checkbox');
          var selectAllCheckbox = document.querySelector('.js--select-all-statements');
          var downloadButton = document.querySelector('.js--download-selected-statements');
          var downloadSpinner = document.querySelector('.js--download-spinner');
          var form = document.getElementById('statements-form');

          // Function to update button state
          function updateButtonState() {
            var checkedCount = document.querySelectorAll('.js--statement-checkbox:checked').length;
            if(downloadButton) {
              downloadButton.disabled = checkedCount === 0;
            }
          }

          // Add event listener to each checkbox
          if(checkboxes && checkboxes.length > 0) {
            checkboxes.forEach(function(checkbox) {
              checkbox.addEventListener('change', updateButtonState);
            });
          }

          // Add event listener to select all checkbox
          if(selectAllCheckbox) {
            selectAllCheckbox.addEventListener('change', function() {
              checkboxes.forEach(function(checkbox) {
                checkbox.checked = selectAllCheckbox.checked;
              });
              updateButtonState();
            });
          }

          // Form submission handler
          if(form) {
            form.addEventListener('submit', function(event) {
              var selectedIds = Array.from(document.querySelectorAll('.js--statement-checkbox:checked'))
                .map(function(cb) { return cb.value; });
              
              if(selectedIds.length === 0) {
                event.preventDefault();
                alert("Please select at least one statement to download.");
                return;
              }
              
              // Show spinner
              downloadButton.disabled = true;
              downloadSpinner.style.display = 'inline-block';
              
              // For single statement, use a different approach
              if(selectedIds.length === 1) {
                // Use fetch directly with no return type specified
                fetch(form.action, {
                  method: 'POST',
                  body: formData,
                  headers: {
                    'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
                  }
                })
                .then(function(response) {
                  if(response.ok) {
                    // For a PDF response, create a blob and download it
                    response.blob().then(function(blob) {
                      var url = window.URL.createObjectURL(blob);
                      var a = document.createElement('a');
                      a.href = url;
                      // Try to get filename from response headers or use default
                      var filename = "statement.pdf";
                      var contentDisposition = response.headers.get('content-disposition');
                      if (contentDisposition) {
                        var filenameMatch = /filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/.exec(contentDisposition);
                        if (filenameMatch && filenameMatch[1]) {
                          filename = filenameMatch[1].replace(/['"]/g, '');
                        }
                      }
                      a.download = filename;
                      a.style.display = 'none';
                      document.body.appendChild(a);
                      a.click();
                      window.URL.revokeObjectURL(url);
                      document.body.removeChild(a);
                      
                      // Reset UI
                      downloadButton.disabled = false;
                      downloadSpinner.style.display = 'none';
                    });
                  } else {
                    throw new Error('Failed to download PDF');
                  }
                })
                .catch(function(error) {
                  console.error('Error downloading statement:', error);
                  alert('Error downloading the statement. Please try again.');
                  downloadButton.disabled = false;
                  downloadSpinner.style.display = 'none';
                });
                
                event.preventDefault();
                return;
              }
              
              // For multiple statements, handle with AJAX
              event.preventDefault();
              
              // Build form data
              var formData = new FormData();
              selectedIds.forEach(function(id) {
                formData.append('statement_ids[]', id);
              });
              
              // Send AJAX request for JSON response
              fetch(form.action + '.json', {
                method: 'POST',
                body: formData,
                headers: {
                  'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
                }
              })
              .then(function(response) {
                if(!response.ok) throw new Error('Network response was not ok');
                return response.json();
              })
              .then(function(data) {
                if(data.pdfs && data.pdfs.length > 0) {
                  data.pdfs.forEach(function(pdf, index) {
                    setTimeout(function() {
                      var dataUrl = 'data:application/pdf;base64,' + pdf.data;
                      var link = document.createElement('a');
                      link.href = dataUrl;
                      link.download = pdf.filename;
                      link.style.display = 'none';
                      document.body.appendChild(link);
                      link.click();
                      document.body.removeChild(link);
                    }, index * 1000);
                  });
                }
                
                // Reset UI
                downloadButton.disabled = false;
                downloadSpinner.style.display = 'none';
              })
              .catch(function(error) {
                console.error('Error downloading statements:', error);
                alert('There was an error downloading the statements. Please try again.');
                downloadButton.disabled = false;
                downloadSpinner.style.display = 'none';
              });
            });
          }
          
          // Initialize button state on page load
          updateButtonState();
        });
  

