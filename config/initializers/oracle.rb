# frozen_string_literal: true

# TODO - refactor OrderStatus so we don't need awesome_nested_set
# Oracle doesn't like the locks in the queries generated by awesome_nested_set.
# The patch below allows us to avoid the exception:
# Combination of limit and lock is not supported. Because generated SQL statements (ArgumentError)
# See https://github.com/rsim/oracle-enhanced/issues/2237
#     https://github.com/rsim/oracle-enhanced/issues/920
#     https://github.com/collectiveidea/awesome_nested_set/issues/166#issuecomment-18916850
if defined?(CollectiveIdea::Acts::NestedSet::Model)
  CollectiveIdea::Acts::NestedSet::Model.class_eval do
    def right_most_bound
      @right_most_bound ||= begin
        return 0 if right_most_node.nil?

        # right_most_node.lock!
        right_most_node[right_column_name] || 0
      end
    end

    # reload left, right, and parent
    def reload_nested_set
      reload(
        :select => "#{quoted_left_column_full_name}, #{quoted_right_column_full_name}, #{quoted_parent_column_full_name}",
        # :lock => true
      )
    end
  end
end

if defined?(ActiveRecord::ConnectionAdapters::OracleEnhancedAdapter)
  ActiveRecord::ConnectionAdapters::OracleEnhancedAdapter.class_eval do

    # The following patched methods address issues with thread safety in specs:
    # RuntimeError: executing in another thread
    # see https://github.com/rsim/oracle-enhanced/pull/2287
    # Hopefully this gets fixed upstream at some point
    def prefetch_primary_key_with_lock?(table_name = nil)
      @lock.synchronize do
        prefetch_primary_key_without_lock?(table_name)
      end
    end
    alias_method :prefetch_primary_key_without_lock?, :prefetch_primary_key?
    alias_method :prefetch_primary_key?, :prefetch_primary_key_with_lock?

    def column_definitions_with_lock(table_name = nil)
      @lock.synchronize do
        column_definitions_without_lock(table_name)
      end
    end
    alias_method :column_definitions_without_lock, :column_definitions
    alias_method :column_definitions, :column_definitions_with_lock

    def pk_and_sequence_for_with_lock(table_name, owner = nil, desc_table_name = nil)
      @lock.synchronize do
        pk_and_sequence_for_without_lock(table_name, owner, desc_table_name)
      end
    end
    alias_method :pk_and_sequence_for_without_lock, :pk_and_sequence_for
    alias_method :pk_and_sequence_for, :pk_and_sequence_for_with_lock

    def primary_keys_with_lock(table_name)
      @lock.synchronize do
        primary_keys_without_lock(table_name)
      end
    end
    alias_method :primary_keys_without_lock, :primary_keys
    alias_method :primary_keys, :primary_keys_with_lock

  end

  # OCI8 does not realize that SafeBuffer is a type of string, so we need to
  # tell it what to do.
  OCI8::BindType::Mapping["ActiveSupport::SafeBuffer"] = OCI8::BindType::String
end
